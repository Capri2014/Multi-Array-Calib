function [ varVec ] = ErrorEstCR( sensorData, rotVec, step )
%ERRORESTR estimate cramer rao lower bound for error variance
%--------------------------------------------------------------------------
%   Required Inputs:
%--------------------------------------------------------------------------
%   sensorData- nx1 cell containing sensor data sturcts
%   estVec- nx3 matrix of rotations for each sensor
%   step- step between test points for numercial differentiation
%
%--------------------------------------------------------------------------
%   Outputs:
%--------------------------------------------------------------------------
%   varVec- nx3 matrix containing rotational variance
%
%--------------------------------------------------------------------------
%   References:
%--------------------------------------------------------------------------
%   This function is part of the Multi-Array-Calib toolbox 
%   https://github.com/ZacharyTaylor/Multi-Array-Calib
%   
%   This code was written by Zachary Taylor
%   zacharyjeremytaylor@gmail.com
%   http://www.zjtaylor.com

%check inputs
validateattributes(sensorData,{'cell'},{'vector'});
for i = 1:length(sensorData)
    validateattributes(sensorData{i},{'struct'},{});
end
validateattributes(rotVec,{'numeric'},{'size',[length(sensorData),3]});
validateattributes(step,{'numeric'},{'scalar','positive','nonzero'});

%pull usful info out of sensorData
RData = zeros(size(sensorData{1}.T_Skm1_Sk,1),3,length(sensorData));
vRData = RData;

for i = 1:length(sensorData)
    RData(:,:,i) = sensorData{i}.T_Skm1_Sk(:,4:6);
    vRData(:,:,i) = sensorData{i}.T_Var_Skm1_Sk(:,4:6);
end

varVec = zeros(length(sensorData),3);

p = zeros(3,3);
for b = 2:length(sensorData)
    Rab = (estMat{1}'*estMat{b})';
    Rab = R2V(Rab);

    estA = sensorData{1}.T_Skm1_Sk(:,4:6)';
    estB = sensorData{b}.T_Skm1_Sk(:,4:6)';
    
    varA = sensorData{1}.T_Var_Skm1_Sk(:,4:6)';
    varB = sensorData{b}.T_Var_Skm1_Sk(:,4:6)';

    for c = 1:3
        for d = 1:3
            R = Rab;
            R(c) = R(c) + step*(d-2);
            R = V2R(R');
            err = R*estA - estB;

            p(d,c) = logpdf(err,varA,varB,R);
        end
    end
    varVec(b,:) = -(step^2)./diff(p,2);
end

end

